/*-------------------------------------------------------------------------
    This file is part of Voxelent's Nucleo

    Nucleo is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3.

    Nucleo is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Nucleo.  If not, see <http://www.gnu.org/licenses/>.
---------------------------------------------------------------------------*/   
try{
    if (!jQuery){
    	alert('Voxelent: jQuery is not loaded. Please include JQuery in your page');	
    }
}catch(e){
    alert('Voxelent: jQuery is not loaded. Please include JQuery in your page');
}


/**
* <p>Contains all the constants and default variables used by Voxelent.</p> 
* 
* <p> These properties aregrouped into sub namespaces. 
* The <code>vxl.c</code> namespace covers all the 'current' objects such as the 
* <i>current view</i> and the <i>current scene</i>.</p>
* <p>The <code>vxl.def</code> namespace contains all the definitions and default values for 
* voxelent's global parameters</p> 
* <p>The <code>vxl.events</code> namespace contains all the events used in Voxelent</p>
* <p>The <code>vxl.go</code> namespace contains all the 'global' objects. These are objects that
* can be accessed from any context in a Voxelent program</p>
* <p>The <code>vxl.version</code> namespace simply informs the version of the current Voxelent platform</p> 
* 
* @namespace Voxelent Main Namespace
* @property {vxl.c}         c           current objects
* @property {vxl.def}       def         definition objects
* @property {vxl.events}    events      events generated by voxelent
* @property {vxl.go}        go          global objects
* @property {vxl.version}   version     version
* 
*/
var vxl = {

/**
* Version
* @namespace Voxelent Version
* @property {String} number         the number of the current version
* @property {String} codename       the codename of the current version
* @property {Array}  plugins        installed plugins if any
*/
version : 
{
   	number : '0.87.6',
   	codename : 'c4n314',
   	plugins  : []
},

/**
 * @namespace Voxelent Default/Definition Objects
 * @property {vxl.def.glsl}     glsl    GLSL constants
 * @property {vxl.def.lut}      lut     Lookup Table Definitions
 * @property {vxl.def.model}    model   Default values for models
 * @property {vxl.def.view}     view    Default values for views 
 * 
 */
def : {
    /**
     * Used mainly by <code>vxlRenderStrategy</code> and its descendents
     * @namespace GLSL constants
     * @property {String} VERTEX_SHADER Vertex Shader Id
     * @property {String} FRAGMENT_SHADER Fragment Shader Id
     * @property {String} MODEL_VIEW_MATRIX  the model view matrix Id
     * @property {String} NORMAL_MATRIX the normal matrix Id
     * @property {String} PERSPECTIVE_MATRIX the perspective matrix Id
     * @property {String} MVP_MATRIX the model view perspective matrix Id
     * @property {String} VERTEX_ATTRIBUTE the vertex attribute Id
     * @property {String} NORMAL_ATTRIBUTE the normal attribute Id
     * @property {String} COLOR_ATTRIBUTE the color attribute Id
     * @property {JSON} blender The program to render blender scenes
     * @property {JSON} lambert The program to render scenes without specular reflections
     * @property {JSON} phong The program to render scenes with specular reflections
     * @property {JSON} bake The program that interleaves buffers for optimized rendering
     */
	glsl			: { 
						VERTEX_SHADER   	: 'VERTEX_SHADER',
						FRAGMENT_SHADER 	: 'FRAGMENT_SHADER',
						MODEL_VIEW_MATRIX  	: 'mModelView',
						NORMAL_MATRIX   	: 'mNormal',
						PERSPECTIVE_MATRIX 	: 'mPerspective',
						MVP_MATRIX          : 'mModelViewPerspective',
						VERTEX_ATTRIBUTE    : 'aVertexPosition',
						NORMAL_ATTRIBUTE    : 'aVertexNormal',
						COLOR_ATTRIBUTE     : 'aVertexColor'
					},
    /** 
     * @namespace Lookup Table Definitions 
     * @property {Array}       list         List of lookup tables available
     * @property {String}      main         Lookup table loaded by default
     */                
	lut             : {
             
						list : ["default","aal","autumn","blackbody","bone","brodmann","cardiac",
								"copper","cortex","cte","french","fs","ge_color","gold","gooch",
								"hot","hotiron","hsv","jet","nih","nih_fire","nih_ice","pink",
								"rainramp","spectrum","surface","x_hot","x_rain"],
                              En
						main:"default"

				    },
	/**
    * @namespace Default values for models
    */
	model			: {
	                   /**
	                    * Diffuse color used by default when a model does not have color information: [0.8,0.8,0.8,1.0] 
	                    */ 
						diffuse: [0.8,0.8,0.8,1.0],
						/** 
						 *  Enumeration with the different loading modes provided for models
						 * <ul>
                         * <li><code>LIVE</code>: Each asset is added to the scene as soon as it is downloaded</li>
                         * <li><code>LATER</code>: The assets are added to the scene only when ALL of them have been downloaded</li> 
                         * <li><code>DETACHED</code>: The assets are never added to the scene. The programmer decides when to do this.</li> 
                         * </ul> 
                         * 
                         * These modes can be used with {@link vxl.api.load} and with {@link vxlScene.setLoadingMode}
                         */
                         loadingMode     : { LIVE:'LIVE', LATER:'LATER', DETACHED:'DETACHED'}
					},
    /**
    * @namespace Default values for views
    * @property {Array} background  A 4-valued array that contains the default background colour for view. The format is [r,g,b,a]
    */
    view			: {
    					background: [135/256,135/256,135/256]
    				},			      
	/**
    * Contains the constants and default values that can be associated with <code>vxlActor</code>
    * 
    * @namespace Default values and constants that can be used with the <code>vxlActor</code> class.
    */
	actor			: {
                        /**
                         * <p>Defines the visualization modes available for instances of vxlActor</p> 
                         * <p>The visualization  modes can be:
                         * <ul>
                         * <li><code>SOLID</code></li>
                         * <li><code>WIREFRAME</code></li> 
                         * <li><code>POINTS</code></li> 
                         * <li><code>LINES</code></li>
                         * </ul>
                         * </p>
                         * <p> to set the actor mode you should use the <code>{@link vxlActor#setVisualizationMode}</code>
                         *  For instance, if you want to visualize the wireframe of your actor you can do something like this:
                         * </p>
                         *  <pre class='prettyprint'>
                         *  var actor = vxl.c.scene.getActorByName('example.json'); //from the current scene
                         *  actor.setVisualizationMode(vxl.def.actor.mode.WIREFRAME)
                         * </pre>
                         * @see vxlActor#setVisualizationMode
                         */
						mode: {	SOLID:'SOLID', WIREFRAME:'WIREFRAME', POINTS:'POINTS', LINES:'LINES'}
					},
	/**
	 * Defines the constants that can be used with <code>vxlCamera</code> 
	 *
     * @namespace Default values for cameras
     */
	camera          : {
                        /** 
                         * 
                         * Enumeration of common camera tasks
                         * 
                         * <p>The camera tasks can be:
                         * <ul>
                         * <li><code>NONE</code></li>
                         * <li><code>PAN</code></li> 
                         * <li><code>ROTATE</code></li> 
                         * <li><code>DOLLY</code></li>
                         * </ul>
                         * </p>
                         *  These constants are used internally and you probably would never need to use them.
                         */
						task      : {	NONE : 0,	PAN : 1,	ROTATE : 2,	DOLLY : 3	},
                        /** 
                         * Camera types available
                         * 
                         * <p>The camera types can be:
                         * <ul>
                         * <li><code>ORBITING</code>: Orbiting Camera - Around the World</li>
                         * <li><code>TRACKING</code>: Tracking Camera - First Person Camera</li> 
                         * </ul>
                         * </p>
                         * 
                         * <p> These modes can be used with the {@link vxlCamera vxlCamera constructor} or with its {@link vxlCamera#setType setType} method</p>
                         */
    					type      : { ORBITING: 'ORBITING', TRACKING : 'TRACKING'},
    					/**
    					 * Right vector constant: [1,0,0] 
    					 */
    					right     : [1,0,0],
    					/**
    					 * Up vector constant: [0,1,0] 
    					 */
    					up        : [0,1,0],
    					/**
    					 * Camera axial or normal vector constant: [0,0,1] 
    					 */
    					normal    : [0,0,1],
    					/**
    					 * Default field of view value: 30 
    					 */
    					fov       : 30,
    					/**
    					 * Default value for the near field: 0.1 
    					 */
    					near      : 0.1,
    					/**
    					 * Default value for the far field: 10000 
    					 */
    					far       : 10000
    					
    					
					},
				 	
    /**
    * @namespace Default values for renderers
    * @property {vxl.def.renderer.mode} mode The rendering mode
    * @property {vxl.def.renderer.rate} rate The rendering rat
    */
	renderer 		: {
			        mode: { TIMER:'TIMER', ANIMFRAME:'ANIFRAME'}, //EXPERIMENTAL NOT WAY TO CANCEL YET },
			        rate : { SLOW: 10000,  NORMAL: 500 }
					}
},

/**
* Congregates all the events fired by Voxelent
* 
* These events are registered with the vxlNotifier
* 
* @namespace Voxelent Events
* @property {String} DEFAULT_LUT_LOADED fired when the default lookup table is loaded
* @property {String} SCENE_UPDATED fired by vxlScene when an actor is added to the scene
* @property {String} MODELS_LOADED fired by vxlModelManager after loading a set of models
* @property {String} MODEL_NEW fired by the vxlModel constructor
* @property {String} ACTOR_MOVED fired by vxlActor when that actor instance is moved
* @property {String} ACTOR_SCALED fired by vxlActor
* @property {String} ACTOR_CHANGED_COLOR fired by vxlActor
* @property {String} ACTOR_CHANGED_SHADING fired by vxlActor
* @property {String} VIEW_NEW fired by the vxlView constructor
* @property {String} SCENE_NEW fired by the vxlScene constructor
* @property {String} READER_DONE fired when a reader is done reading window.File(s)
* @see {vxlNotifier}
*/
events : {
	DEFAULT_LUT_LOADED 	   : 'vxl.events.DEFAULT_LUT_LOADED',
	SCENE_UPDATED		   : 'vxl.events.SCENE_UPDATED',
	MODELS_LOADING         : 'vxl.events.MODELS_LOADING',
	MODEL_NEW              : 'vxl.events.MODEL_NEW',
	MODELS_LOADED		   : 'vxl.events.MODELS_LOADED',
	ACTOR_MOVED            : 'vxl.events.ACTOR_MOVED',
	ACTOR_SCALED           : 'vxl.events.ACTOR_SCALED',
	ACTOR_CHANGED_COLOR    : 'vxl.events.ACTOR_CHANGED_COLOR',
	ACTOR_CHANGED_SHADING  : 'vxl.events.ACTOR_CHANGED_SHADING',
	VIEW_NEW               : 'vxl.events.VIEW_NEW',
	SCENE_NEW              : 'vxl.events.SCENE_NEW',
	READER_DONE            : 'vxl.events.READER_DONE'
},


/**
* @namespace Voxelent Global Objects
*
*/
go : {
    debug 	 		    : false,					  
    notifier            : undefined,
    modelManager        : undefined,
    lookupTableManager  : undefined,
    views               : [],
    scenes              : [],
    renderman : {

		_timid : 0,
		_rates : [],
		_stop  : false,
		
		render : function(){
			for(var i=0; i<vxl.go.views.length;i+=1){
				vxl.go.views[i].renderer.render();
			}
			if (vxl.go.renderman._stop != true){
			 vxl.go.renderman._timid = window.requestAnimFrame(vxl.go.renderman.render);
			}
			else{
			    vxl.go.renderman._stop = false;
			}
		},
		
		cancel : function(){
		    vxl.go.renderman._stop = true;
		},
		
		slow : function(){
			/*vxl.go.renderman._rates = [];
			for(var i = 0; i < vxl.go.renderman._views.length; i++){
			    if (vxl.go.renderman._views[i].renderer.mode == vxl.def.renderer.mode.ANIMFRAME) continue;
				vxl.go.console('vxl.go.slowRendering: slow rendering on view '+vxl.go.renderman._views[i].name,true);
				vxl.go.renderman._rates.push(vxl.go.renderman._views[i].renderer.renderRate);
				vxl.go.renderman._views[i].renderer.setRenderRate(vxl.def.renderer.rate.SLOW);
			}*/
		},
		
		normal : function(){
			/*for(var i = 0; i < vxl.go.renderman._views.length; i++){
			    if (vxl.go.renderman._views[i].renderer.mode == vxl.def.renderer.mode.ANIMFRAME) continue;
				vxl.go.console('vxl.go.normalRendering: go back to normal rendering on view '+vxl.go.renderman._views[i].name,true);
				if (vxl.go.renderman._rates[i] != undefined){
				    vxl.go.renderman._views[i].renderer.setRenderRate(vxl.go.renderman._rates[i]);
				}
			}*/
		}
	},
	
	console : function(txt,flag) { 
		if (this.debug == true || flag){
			console.info(txt);
		}
	}
	
},

/**
* @namespace Voxelent Current Objects
* @property {vxlScene}          scene       the current scene
* @property {vxlView}           view        the current view
* @property {vxlCamera}         camera      the current camera
* @property {vxlActor}          actor       the current actor
* @property {vxlFrameAnimation} animation   the current animation
*/
c : {
	scene		: undefined,
	view		: undefined,
	camera 		: undefined,
	actor		: undefined,  
	animation 	: undefined
},
/**
 * Utility functions
 * @namespace Voxelent Util methods
 * 
 */
util : {
    /**
     * Formats Arrays, vec3 and vec4 for display
     * 
     * @param {Array, vec3, vec4} arr the object to format
     * @param {Number} digits the number of decimal figures
     */
	format: function(arr, digits){
		var p = Math.pow(10,digits);
		if (typeof(arr) == 'object'){
			
			var result = '['; 
			for (var i=0; i < arr.length-1; i+=1){
				result  += Math.round(arr[i] * p) / p + ', '; 
			}
			result += Math.round(arr[arr.length-1] * p) / p  + ']'
		}
		else if (typeof(arr) == 'number'){
			result = '[' + Math.round(arr * p) / p  + ']';
		}
		return result;
	},
	
	/**
	 * Creates a vector from a set of parameters
	 * @param {Array, vec3, Number} x it can be an Array, a vec3 or a number
	 * @param {Number} y if x is a number, this parameter corresponds to the y-component
	 * @param {Number} z if x is a number, this parameter corresponds to the z-component
	 */
	createVec3: function(x,y,z){
	    var vvv = vec3.create();
	    if (x instanceof Array){
            vec3.set(vec3.create(x), vvv)
        }
        else if (x instanceof determineMatrixArrayType()){
            vec3.set(x, vvv)
        }
        else{
            vec3.set(vec3.createFrom(x,y,z), vvv);
        }
        return vvv;
	},
	/**
     * Creates an array from a set of parameters
     * @param {Array, vec3, Number} x it can be an Array, a vec3 or a number
     * @param {Number} y if x is a number, this parameter corresponds to the y-component
     * @param {Number} z if x is a number, this parameter corresponds to the z-component
     */
	createArr3: function(x,y,z){
	    var vvv = []
        if (x instanceof Array || x instanceof determineMatrixArrayType()){
            vvv[0] = x[0];
            vvv[1] = x[1];
            vvv[2] = x[2];
        }
        else{
            vvv[0] = x;
            vvv[1] = y;
            vvv[2] = z;
        }
        return vvv;
	},
	
	generateUID: function(){
	       function S4() {
                return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
            }
        return (S4()+"-"+S4()+"-"+S4()+"-"+S4());
    },
    
    extend : function(){
      var ret = {};
      var len = arguments.length;
      for (var i=0; i<len; i++) {
        for (p in arguments[i]) {
          if (arguments[i].hasOwnProperty(p)) {
            ret[p] = arguments[i][p];
          }
        }
      }
      return ret;
    }
}

};

Array.prototype.max = function(){
	return Math.max.apply(null, this);
};

Array.prototype.min = function(){
	return Math.min.apply(null, this);
};




Array.prototype.hasObject = (
  !Array.indexOf ? function (o)
  {
    var l = this.length + 1;
    while (l -= 1)
    {
        if (this[l - 1] === o)
        {
            return true;
        }
    }
    return false;
  } : function (o)
  {
    return (this.indexOf(o) !== -1);
  }
);

window.requestAnimFrame = (function(){
    return  window.requestAnimationFrame       || 
        window.webkitRequestAnimationFrame || 
        window.mozRequestAnimationFrame    || 
        window.oRequestAnimationFrame      || 
        window.msRequestAnimationFrame     || 
        function(/* function */ callback, /* DOMElement */ element){
            return window.setTimeout(callback, 1000 / 60);
        };
})();

window.cancelRequestAnimFrame = ( function() {
    return window.cancelAnimationFrame          ||
        window.webkitCancelRequestAnimationFrame    ||
        window.mozCancelRequestAnimationFrame       ||
        window.oCancelRequestAnimationFrame     ||
        window.msCancelRequestAnimationFrame        ||
        clearTimeout
})();


//$(window).bind('focus', vxl.go.renderman.normal);
//$(window).bind('blur', vxl.go.renderman.slow);
